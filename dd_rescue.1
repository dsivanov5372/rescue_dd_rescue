.\" $Id$
.
.TH dd_rescue 1 "2013-02-24" "Kurt Garloff" "Rescue copy tool"
.
.SH NAME
dd_rescue \- Rescue copy tool
.
.SH SYNOPSIS
.na
.nh
.B dd_rescue
[options] infile outfile
.
.br
.B dd_rescue
[options] [-2/-3/-4/-z/-Z seed/seedfile] outfile
.
.br
.B dd_rescue
[options] [--shred2/--shred3/--shred4/--random/--frandom seed/seedfile] outfile
.
.SH DESCRIPTION
.B dd_rescue
is a tool that copies data from a source (file, block device, pipe, ...) 
to one (or several) output file(s). 
.PP
If input and output files are seekable (block devices or regular files),
.B dd_rescue
does copy with large blocks (softbs) to increase performance. When
a read error is encountered,
.B dd_rescue
falls back to reading smaller blocks (hardbs), to allow to recover the maximum
amount of data. If blocks can still not be read,
.B dd_rescue
by default skips over them also in the output file, avoiding to overwrite
data that might have been copied there successfully in a previous run.
(Option -A / --alwayswrite changes this.).
.
.PP
.B dd_rescue
can copy in reverse direction as well, allowing to approach a bad spot 
from both directions. As trying to read over a bad spot of significant size
can take very long (and potentially cause further damage), this is an important
optimization when recovering data. The
.B dd_rhelp
tool takes advantage of this and automates data recovery.
.B dd_rescue
does not (by default) truncate the output file.
.PP
.B dd_rescue
by default reports on progress, and optionally also writes into a logfile.
.B dd_rescue
has a wealth of options that influence its behaviour, such as the possibility
to use direct IO for input/output, to use fallocate() to preallocate space
for the output file, using splice copy (in kernel zerocopy) for efficiency,
looking for empty blocks to create sparse files, or using a pseudo random
number generator (PRNG) to quickly overwrite data with random numbers.
.
.SH OPTIONS
When parsing numbers, 
.B dd_rescue
assumes bytes. It accepts the following suffixes:
.br 
b -- 512 size units (blocks)
.br 
k -- 1024 size units (binary kilobytes, kiB)
.br 
M -- 1024^2 size units (binary megabytes, MiB)
.br 
G -- 1024^3 size units (binary gigabytes, GiB)
.PP
The following options may be used to modify the behaviour of 
.B dd_rescue 
.SS General options
.TP 8
.BR \-h ", " \-\-help
This option tells
.B dd_rescue
to output a list of options and exit.
.TP 8
.BR \-V ", " \-\-version
Display version number and exit.
.TP 8
.BR \-q ", " \-\-quiet
tells
.B dd_rescue
to be less verbose.
.TP 8
.BR \-v ", " \-\-verbose
makes
.B dd_rescue
more verbose.
.BR \-v ", " \-\-verbose
makes
.B dd_rescue
more verbose.
.TP 8
.BR \-f ", " \-\-force
makes
.B dd_rescue
skip some sanity checks (e.g. automatically setting reverse direction when 
input and output file are the same and ipos < opos).
.TP 8
.BR \-i ", " \-\-interactive
tells
.B dd_rescue
to ask before overwriting existing files.
.
.SS Block sizes
.TP 8
.BI \-b\  softbs \fR,\ \fB\-\-softbs= softbs \fR,\ \fB\-\-bs= softbs
sets the (larger) blocksize to
.IR softbs  
bytes.
.B dd_rescue
will transfer chunks of that size unless a read error is encountered (or the 
end of the input file or the maximum transfer size has been reached).
The default value for this is 64k for buffered I/O and 1M for direct I/O.
.TP 8
.BI \-B\  hardbs \fR,\ \fB\-\-hardbs= hardbs \fR,\ \fB\-\-block\-size= hardbs
sets the (smaller) fallback blocksize to
.IR hardbs
bytes. When
.B dd_rescue
encounters read errors, it will fall back to copying data in chunks of 
this size. This value defaults to 4k for buffered I/O and 512 bytes for
direct I/O.
.br
.IR hardbs
should be equal to or smaller than
.IR softbs .
If both block sizes are identical, no fallback mechanism (and thus no
retry) will take place on read errors.
.TP 8
.BI \-y\  syncfreq \fR,\ \fB\-\-syncfreq= syncfreq
tells
.B dd_rescue
to call fsync() on the output file every 
.IR syncfreq
blocks (in terms of
.IR softbs
sized blocks). It will also update the progress indicator at least as
often. By default,
.IR syyncfreq
is set to 0, meaning that fsync() is only issued at the end of the
copy operation.
.
.SS Positions and length
.TP 8
.BI \-s\  ipos \fR,\ \fB\-\-ipos= ipos \fR,\ \fB\-\-input\-position= ipos
sets the starting position of the 
.IR infile
to
.IR ipos .
Note that ipos is specified in bytes (but suffixes can be used, see above), 
not in terms of 
.IR softbs
or
.IR hardbs
sized blocks.
The default value for this is 0. When reverse direction copy is used, an
.IR ipos
of 0 is treated specially, meaning the end of file.
.br
Negative positions result in an error message.
.TP 8
.BI \-S\  opos \fR,\ \fB\-\-opos= opos \fR,\ \fB\-\-output\-position= opos
sets the starting position of the
.IR outfile
to
.IR opos .
If not specified,
.IR opos
is set to
.IR ipos ,
so the file offsets in input and output file are the same.
For reverse direction copy, an explicit 
.IR opos 
of 0 will position at the end of the output file.
.TP 8
.BR \-x ", " \-\-extend
changes the interpretation of the output position to start at the 
end of the existing output file, making appending to a file convenient.
If the output file does not exist, an error will be reported and
.B dd_rescue
aborted.
.TP 8
.BI \-m\  maxxfer \fR,\ \fB\-\-maxxfer= maxxfer \fR,\ \fB\-\-max\-size= maxxfer
specifies the maximum number of bytes (suffixes apply, but it's NOT
counted in blocks) that 
.B dd_rescue 
copies. If EOF is encountered before 
.IR maxxfer
bytes have been transferred, this option will be silently ignored.
.TP 8
.BR \-M ", " \-\-noextend
tells 
.B dd_rescue
to not extend the output file. This option is particularly helpful
when overwriting a file with random data or zeroes for safe data
destruction. If the output file does not exist, an error message
will be generated and the program be aborted.
.SS Error handling
.TP 8
.BI \-e\  maxerr \fR,\ \fB\-\-maxerr= maxerr
tells
.B dd_rescue
to exit, after
.IR maxerr
read errors have been encountered. By default, this is set to 0,
resulting in
.B dd_rescue
trying to move on until it hits EOF (or
.IR maxxfer
bytes have been transferred).
.TP 8
.BR \-w ", " \-\-abort_we
makes
.B dd_rescue
abort on any write errors. By default, write errors are ignored.
This is because for buffered writes, errors can't be detected and
located reliably anyway. Also, write errors are not often reported
to userspace, as hard drives e.g. reallocate bad blocks on writes
and the OS block layer typically also does some retries on write
operations. Note that 
.B dd_rescue
does exit if writes to the output file result in the Operating
System reporting that no space is left.
.SS Sparse files and write avoidance
.TP 8
.BR \-A ", " \-\-alwayswrite
changes the behaviour of
.B dd_rescue
to write zeroes to the output file when the input file could not
be read. By default, it just skips over, leaving whatever content
was in the output file at the file position before. The default
behaviour may be desired, if e.g. previous copy operations may have
resulted in good data being in place; it may be undesired if the
output file may contain garbage (or sensitive information) that should
rather be overwritten with zeroes.
.TP 8
.BR \-a ", " \-\-sparse
will make 
.B dd_rescue
look for empty blocks (of 
.IR softbs
size), i.e. blocks filled with zeroes. Rather than writing those
zeroes to the output file, it will then skip forward in the output
file, resulting in a sparse file, saving space in the output filesystem
(if it supports sparse files). Note that if the output file does already
exist and already has data stored at the location where zeroes are skipped
over, this will result in an incomplete copy in that the output file is
different from the input file, where blocks of zeroes are skipped over.
.B dd_rescue
tries to detect this and issue a warning, but it does not prevent this
from happening
.TP 8
.BR \-W ", " \-\-avoidwrite
results in 
.B dd_rescue
reading a block (
.IR softbs
sized) from the output file prior to writing it. If it is already identical
with the data that would be written to it, the writes are actually avoided.
This option may be useful for devices, where e.g. writes should be avoided
(e.g. because they may impact the reaining lifetime or because they are very
slow compared to reads).
.SS Other optimizations
.TP 8
.BR \-R ", " \-\-repeat
tells 
.B dd_rescue
to only read one block (
.IR softbs
sized) and then repeatedly write it to the output file.
Note that this results in never hitting EOF on the input file and should be
used with a limit for the transfer size (options -m or -M) or when filling
up an output device completely.
.br
This option is automatically set, if the input file name equals "/dev/zero".
.TP 8
.BR \-k ", " \-\-splice
tells
.B dd_rescue
to use the Linux in-kernel zerocopy splice() copy operation rather than
reading blocks into a userspace buffer. Note that this operation mode
does prevent the support of a number of
.B dd_rescue
features that can normally be used, such as falling back to smaller block
sizes, avoiding writes, sparse mode, repeat optimization, reverse direction
copy. A warning is issued to make the user aware.
.TP 8
.BR \-P ", " \-\-fallocate
results in 
.B dd_rescue
calling fallocate() on the output file, telling the filesystem how much
space to preallocate for the output file. (The size is determined by the
expected last position, as inferred from the input file length and 
.IR maxxfer
). On filesystems that support it, this results in them making better
allocation decisions, avoiding fragmentation. (Note that it does not
make sense to use sparse together with fallocate().)
.SS Misc options
.TP 8
.BR \-r ", " \-\-reverse
tells
.B dd_rescue
to copy in reverse direction, starting at 
.IR ipos
(with special case 0 meaning EOF) and working towards the beginning of
the file. This is especially helpful if the input file has a bad spot
which can be extremely slow to skip over, so approaching it from both
directions saves a lot of time (and may prevent further damage).
.br
Note that 
.B dd_rescue
does automatically switch to reverse direction copy, if input and output
file are identical and the input position is smaller than the output 
position, similar to the intelligence that memmove() uses to prevent
loss of data when overlapping areas are copied. The option -f / --force
does prevent this intelligence from happening.
.TP 8
.BR \-p ", " \-\-preserve
When copying files, this option does result in file metadata (timestamps,
ownership, access rights) to be copied, similar to the option with the
same name in the cp program.
.br
Note that 
.B dd_rescue
at this point does not have support for copying extended attributes
or ACLs. (But the behaviour of -p is still consistent with cp.)
.TP 8
.BR \-t ", " \-\-truncate
...
.TP 8
.BR \-T ", " \-\-trunclast
...
.TP 8
.BR \-d ", " \-\-odir_in
...
.TP 8
.BR \-D ", " \-\-odir_out
...


.SS Logging
.TP 8
.BI \-l\  logfile \fR,\ \fB\-\-logfile= logfile
...
.TP 8
.BI \-o\  bbfile \fR,\ \fB\-\-bbfile= bbfile
...
.SS Multiple output files
.TP 8
.BI \-Y\  ofileX \fR,\ \fB\-\-outfile= ofileX \fR,\ \fB\-\-of= ofileX


.SS Random data generation
.TP 8
.BI \-z\  RANDSEED \fR,\ \fB\-\-random= RANDSEED
.TP
.BI \-Z\  RANDSEED \fR,\ \fB\-\-frandom= RANDSEED
.TP
.BI \-2\  RANDSEED \fR,\ \fB\-\-shred2= RANDSEED
.TP
.BI \-3\  RANDSEED \fR,\ \fB\-\-shred3= RANDSEED
.TP 
.BI \-4\  RANDSEED \fR,\ \fB\-\-shred4= RANDSEED






...
.SH EXAMPLES
...
.SH REFERENCES

