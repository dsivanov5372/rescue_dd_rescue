.\" $Id$
.
.TH dd_rescue 1 "2013-02-24" "Kurt Garloff" "Rescue copy tool"
.
.SH NAME
dd_rescue \- Rescue copy tool
.
.SH SYNOPSIS
.na
.nh
.B dd_rescue
[options] infile outfile
.
.br
.B dd_rescue
[options] [-2/-3/-4/-z/-Z seed/seedfile] outfile
.
.br
.B dd_rescue
[options] [--shred2/--shred3/--shred4/--random/--frandom seed/seedfile] outfile
.
.SH DESCRIPTION
.B dd_rescue
is a tool that copies data from a source (file, block device, pipe, ...) 
to one (or several) output file(s). 
.PP
If input and output files are seekable (block devices or regular files),
.B dd_rescue
does copy with large blocks (softbs) to increase performance. When
a read error is encountered,
.B dd_rescue
falls back to reading smaller blocks (hardbs), to allow to recover the maximum
amount of data. If blocks can still not be read,
.B dd_rescue
by default skips over them also in the output file, avoiding to overwrite
data that might have been copied there successfully in a previous run.
(Option -A / --alwayswrite changes this.).
.
.PP
.B dd_rescue
can copy in reverse direction as well, allowing to approach a bad spot 
from both directions. As trying to read over a bad spot of significant size
can take very long (and potentially cause further damage), this is an important
optimization when recovering data. The
.B dd_rhelp
tool takes advantage of this and automates data recovery.
.B dd_rescue
does not (by default) truncate the output file.
.PP
.B dd_rescue
by default reports on progress, and optionally also writes into a logfile.
.B dd_rescue
has a wealth of options that influence its behaviour, such as the possibility
to use direct IO for input/output, to use fallocate() to preallocate space
for the output file, using splice copy (in kernel zerocopy) for efficiency,
looking for empty blocks to create sparse files, or using a pseudo random
number generator (PRNG) to quickly overwrite data with random numbers.
.
.SH OPTIONS
When parsing numbers, 
.B dd_rescue
assumes bytes. It accepts the following suffixes:
.br 
b -- 512 size units (blocks)
.br 
k -- 1024 size units (binary kilobytes, kiB)
.br 
M -- 1024^2 size units (binary megabytes, MiB)
.br 
G -- 1024^3 size units (binary gigabytes, GiB)
.PP
The following options may be used to modify the behaviour of 
.B dd_rescue 
.SS General options
.TP 8
.BR \-h ", " \-\-help
This option tells
.B dd_rescue
to output a list of options and exit.
.TP 8
.BR \-V ", " \-\-version
Display version number and exit.
.TP 8
.BR \-q ", " \-\-quiet
tells
.B dd_rescue
to be less verbose.
.TP 8
.BR \-v ", " \-\-verbose
makes
.B dd_rescue
more verbose.
.BR \-v ", " \-\-verbose
makes
.B dd_rescue
more verbose.
.TP 8
.BR \-f ", " \-\-force
makes
.B dd_rescue
skip some sanity checks (e.g. automatically setting reverse direction when 
input and output file are the same and ipos < opos).
.TP 8
.BR \-i ", " \-\-interactive
tells
.B dd_rescue
to ask before overwriting existing files.
.
.SS Block sizes
.TP 8
.BI \-b\  softbs \fR,\ \fB\-\-softbs= softbs
sets the (larger) blocksize to
.IR softbs  
bytes.
.B dd_rescue
will transfer chunks of that size unless a read error is encountered (or the 
end of the input file or the maximum transfer size has been reached).
The default value for this is 64k for buffered I/O and 1M for direct I/O.
.TP 8
.BI \-B\  hardbs \fR,\ \fB\-\-hardbs= hardbs
sets the (smaller) fallback blocksize to
.IR hardbs
bytes. When
.B dd_rescue
encounters read errors, it will fall back to copying data in chunks of 
this size. This value defaults to 4k for buffered I/O and 512 bytes for
direct I/O.
.br
.IR hardbs
should be equal to or smaller than
.IR softbs .
If both block sizes are identical, no fallback mechanism (and thus no
retry) will take place on read errors.
.TP 8
.BI \-y\  syncfreq \fR,\ \fB\-\-syncfreq= syncfreq
tells
.B dd_rescue
to call fsync() on the output file every 
.IR syncfreq
blocks (in terms of
.IR softbs
sized blocks). It will also update the progress indicator at least as
often. By default,
.IR syyncfreq
is set to 0, meaning that fsync() is only issued at the end of the
copy operation.
.
.SS Positions and length
.TP 8
.BI \-s\  ipos \fR,\ \fB\-\-ipos= ipos
sets the starting position of the 
.IR infile
to
.IR ipos .
Note that ipos is specified in bytes (but suffixes can be used, see above), 
not in terms of 
.IR softbs
or
.IR hardbs
sized blocks.
The default value for this is 0. When reverse direction copy is used, an
.IR ipos
of 0 is treated specially, meaning the end of file.
.br
Negative positions result in an error message.
.TP 8
.BI \-S\  opos \fR,\ \fB\-\-opos= opos
sets the starting position of the
.IR outfile
to
.IR opos .
If not specified,
.IR opos
is set to
.IR ipos ,
so the file offsets in input and output file are the same.
For reverse direction copy, an explicit 
.IR opos 
of 0 will position at the end of the output file.
.TP 8
.BR \-x ", " \-\-extend
changes the interpretation of the output position to start at the 
end of the existing output file, making appending to a file convenient.
If the output file does not exist, an error will be reported and
.B dd_rescue
aborted.
.TP 8
.BI \-m\  maxxfer \fR,\ \fB\-\-maxxfer= maxxfer
specifies the maximum number of bytes (suffixes apply, but it's NOT
counted in blocks) that 
.B dd_rescue 
copies. If EOF is encountered before 
.IR maxxfer
bytes have been transferred, this option will be silently ignored.
.TP 8
.BR \-M ", " \-\-noextend
tells 
.B dd_rescue
to not extend the output file. This option is particularly helpful
when overwriting a file with random data or zeroes for safe data
destruction. If the output file does not exist, an error message
will be generated and the program be aborted.
.SS Error handling
.TP 8
.BI \-e\  maxerr \fR,\ \fB\-\-maxerr= maxerr
tells
.B dd_rescue
to exit, after
.IR maxerr
read errors have been encountered. By default, this is set to 0,
resulting in
.B dd_rescue
trying to move on until it hits EOF (or
.IR maxxfer
bytes have been transferred).
.TP 8
.BR \-w ", " \-\-abort_we
makes
.B dd_rescue
abort on any write errors. By default, write errors are ignored.
This is because for buffered writes, errors can't be detected and
located reliably anyway. Also, write errors are not often reported
to userspace, as hard drives e.g. reallocate bad blocks on writes
and the OS block layer typically also does some retries on write
operations.



...
.SH EXAMPLES
...
.SH REFERENCES

