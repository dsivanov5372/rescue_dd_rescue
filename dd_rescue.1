.\" $Id$
.
.TH dd_rescue 1 "2014-04-30" "Kurt Garloff" "Data recovery and protection tool"
.
.SH NAME
dd_rescue \- Data recovery and protection tool
.
.SH SYNOPSIS
.na
.nh
.B dd_rescue
[options] infile outfile
.
.br
.B dd_rescue
[options] [-2/-3/-4/-z/-Z seed/seedfile] outfile
.
.br
.B dd_rescue
[options] [--shred2/--shred3/--shred4/--random/--frandom seed/seedfile] outfile
.
.SH DESCRIPTION
.B dd_rescue
is a tool that copies data from a source (file, block device, pipe, ...) 
to one (or several) output file(s). 
.PP
If input and output files are seekable (block devices or regular files),
.B dd_rescue
does copy with large blocks (softbs) to increase performance. When
a read error is encountered,
.B dd_rescue
falls back to reading smaller blocks (hardbs), to allow to recover the maximum
amount of data. If blocks can still not be read,
.B dd_rescue
by default skips over them also in the output file, avoiding to overwrite
data that might have been copied there successfully in a previous run.
(Option -A / --alwayswrite changes this.).
.
.PP
.B dd_rescue
can copy in reverse direction as well, allowing to approach a bad spot 
from both directions. As trying to read over a bad spot of significant size
can take very long (and potentially cause further damage), this is an important
optimization when recovering data. The
.B dd_rhelp
tool takes advantage of this and automates data recovery.
.B dd_rescue
does not (by default) truncate the output file.
.PP
.B dd_rescue
by default reports on progress, and optionally also writes into a logfile.
It has a progress bar and gives an estimate for the remaining time.
.B dd_rescue
has a wealth of options that influence its behaviour, such as the possibility
to use direct IO for input/output, to use fallocate() to preallocate space
for the output file, using splice copy (in kernel zerocopy) for efficiency,
looking for empty blocks to create sparse files, or using a pseudo random
number generator (PRNG) to quickly overwrite data with random numbers.
.PP
The modes to overwrite partitions or files with pseudo random numbers make
.B dd_rescue
a tool that can be used for secure data deletion and thus not just a
data recovery and backup tool but also a data protection tool.
.PP
You can use "-" as infile or outfile, meaning stdin or stdout. Note that
this means that either file is not seekable, limiting the usefulness of
some of dd_rescues features.
.
.SH OPTIONS
When parsing numbers, 
.B dd_rescue
assumes bytes. It accepts the following suffixes:
.br 
b -- 512 size units (blocks)
.br 
k -- 1024 size units (binary kilobytes, kiB)
.br 
M -- 1024^2 size units (binary megabytes, MiB)
.br 
G -- 1024^3 size units (binary gigabytes, GiB)
.PP
The following options may be used to modify the behaviour of 
.B dd_rescue .
.
.SS General options
.TP 8
.BR \-h ", " \-\-help
This option tells
.B dd_rescue
to output a list of options and exit.
.TP 8
.BR \-V ", " \-\-version
Display version number and exit.
.TP 8
.BR \-q ", " \-\-quiet
tells
.B dd_rescue
to be less verbose.
.TP 8
.BR \-v ", " \-\-verbose
makes
.B dd_rescue
more verbose.
.TP 8
.BI \-c\  0/1 \fR,\ \fB\-\-color= 0/1
controls whether
.B dd_rescue
uses colors. By default it does, unless the terminal type from TERM is 
unknown or dumb or ends in -m or -mono.
.TP 8
.BR \-f ", " \-\-force
makes
.B dd_rescue
skip some sanity checks (e.g. automatically setting reverse direction when 
input and output file are the same and ipos < opos).
.TP 8
.BR \-i ", " \-\-interactive
tells
.B dd_rescue
to ask before overwriting existing files.
.
.SS Block sizes
.TP 8
.BI \-b\  softbs \fR,\ \fB\-\-softbs= softbs \fR,\ \fB\-\-bs= softbs
sets the (larger) blocksize to
.IR softbs  
bytes.
.B dd_rescue
will transfer chunks of that size unless a read error is encountered (or the 
end of the input file or the maximum transfer size has been reached).
The default value for this is 64k for buffered I/O and 1M for direct I/O.
.TP 8
.BI \-B\  hardbs \fR,\ \fB\-\-hardbs= hardbs \fR,\ \fB\-\-block\-size= hardbs
sets the (smaller) fallback blocksize to
.IR hardbs
bytes. When
.B dd_rescue
encounters read errors, it will fall back to copying data in chunks of 
this size. This value defaults to 4k for buffered I/O and 512 bytes for
direct I/O.
.br
.IR hardbs
should be equal to or smaller than
.IR softbs .
If both block sizes are identical, no fallback mechanism (and thus no
retry) will take place on read errors.
.TP 8
.BI \-y\  syncsize \fR,\ \fB\-\-syncfreq= syncsize
tells
.B dd_rescue
to call fsync() on the output file every 
.IR syncsize
bytes (will be rounded to multiples of 
.IR softbs
sized blocks). It will also update the progress indicator at least as
often. By default,
.IR syncsize
is set to 0, meaning that fsync() is only issued at the end of the
copy operation.
.
.SS Positions and length
.TP 8
.BI \-s\  ipos \fR,\ \fB\-\-ipos= ipos \fR,\ \fB\-\-input\-position= ipos
sets the starting position of the 
.IR infile
to
.IR ipos .
Note that ipos is specified in bytes (but suffixes can be used, see above), 
not in terms of 
.IR softbs
or
.IR hardbs
sized blocks.
The default value for this is 0. When reverse direction copy is used, an
.IR ipos
of 0 is treated specially, meaning the end of file.
.br
Negative positions result in an error message.
.TP 8
.BI \-S\  opos \fR,\ \fB\-\-opos= opos \fR,\ \fB\-\-output\-position= opos
sets the starting position of the
.IR outfile
to
.IR opos .
If not specified,
.IR opos
is set to
.IR ipos ,
so the file offsets in input and output file are the same.
For reverse direction copy, an explicit 
.IR opos 
of 0 will position at the end of the output file.
.TP 8
.BR \-x ", " \-\-extend ", " \-\-append
changes the interpretation of the output position to start at the 
end of the existing output file, making appending to a file convenient.
If the output file does not exist, an error will be reported and
.B dd_rescue
aborted.
.TP 8
.BI \-m\  maxxfer \fR,\ \fB\-\-maxxfer= maxxfer \fR,\ \fB\-\-max\-size= maxxfer
specifies the maximum number of bytes (suffixes apply, but it's NOT
counted in blocks) that 
.B dd_rescue 
copies. If EOF is encountered before 
.IR maxxfer
bytes have been transferred, this option will be silently ignored.
.TP 8
.BR \-M ", " \-\-noextend
tells 
.B dd_rescue
to not extend the output file. This option is particularly helpful
when overwriting a file with random data or zeroes for safe data
destruction. If the output file does not exist, an error message
will be generated and the program be aborted.
.
.SS Error handling
.TP 8
.BI \-e\  maxerr \fR,\ \fB\-\-maxerr= maxerr
tells
.B dd_rescue
to exit, after
.IR maxerr
read errors have been encountered. By default, this is set to 0,
resulting in
.B dd_rescue
trying to move on until it hits EOF (or
.IR maxxfer
bytes have been transferred).
.TP 8
.BR \-w ", " \-\-abort_we
makes
.B dd_rescue
abort on any write errors. By default, write errors are ignored.
This is because for buffered writes, errors can't be detected and
located reliably anyway. Also, write errors are not often reported
to userspace, as hard drives e.g. reallocate bad blocks on writes
and the OS block layer typically also does some retries on write
operations. Note that 
.B dd_rescue
does exit if writes to the output file result in the Operating
System reporting that no space is left.
.
.SS Sparse files and write avoidance
.TP 8
.BR \-A ", " \-\-alwayswrite
changes the behaviour of
.B dd_rescue
to write zeroes to the output file when the input file could not
be read. By default, it just skips over, leaving whatever content
was in the output file at the file position before. The default
behaviour may be desired, if e.g. previous copy operations may have
resulted in good data being in place; it may be undesired if the
output file may contain garbage (or sensitive information) that should
rather be overwritten with zeroes.
.TP 8
.BR \-a ", " \-\-sparse
will make 
.B dd_rescue
look for empty blocks (of at least half of 
.IR softbs
size), i.e. blocks filled with zeroes. Rather than writing those
zeroes to the output file, it will then skip forward in the output
file, resulting in a sparse file, saving space in the output filesystem
(if it supports sparse files). Note that if the output file does already
exist and already has data stored at the location where zeroes are skipped
over, this will result in an incomplete copy in that the output file is
different from the input file at the location where blocks of zeroes 
were skipped over.
.B dd_rescue
tries to detect this and issue a warning, but it does not prevent this
from happening
.TP 8
.BR \-W ", " \-\-avoidwrite
results in 
.B dd_rescue
reading a block (
.IR softbs
sized) from the output file prior to writing it. If it is already identical
with the data that would be written to it, the writes are actually avoided.
This option may be useful for devices, where e.g. writes should be avoided
(e.g. because they may impact the reaining lifetime or because they are very
slow compared to reads).
.
.SS Other optimizations
.TP 8
.BR \-R ", " \-\-repeat
tells 
.B dd_rescue
to only read one block (
.IR softbs
sized) and then repeatedly write it to the output file.
Note that this results in never hitting EOF on the input file and should be
used with a limit for the transfer size (options -m or -M) or when filling
up an output device completely.
.br
This option is automatically set, if the input file name equals "/dev/zero".
.TP 8
.BR \-u ", " \-\-rmvtrim
instructs
.B dd_rescue
to remove the output file after writing to it has completed and issue
a FITRIM on the filesystem that contains the output file. This makes
only sense if writing zeros (or random numbers) as opposed to useful
content from another file. (dd_rescue will ask for confirmation if
this is specified with a normal input file and no \-f (\-\-force) is
used.) This option may be used to ensure that all empty
blocks of a filesystem are filled with zeros (rather than containing 
fragments of deleted files with possibly sensitive information).
.br
The FITRIM ioctl (on Linux) tells the flash storage to consider
the freed space as unused (like the fstrim tool or the discard
option) by issuing ATA TRIM commands. This will only succeed with
superuser privileges (but the error can otherwise be safely
ignored). This is useful to ensure full performance of flash
memory / SSDs. Note that FITRIM can take a while on large
filesystems, especially if the filesystems are not mounted with
the discard option and have not been trimmed (with e.g. fstrim)
for a while. Not all filesystems and not all flash-based storage
support this.
.TP 8
.BR \-k ", " \-\-splice
tells
.B dd_rescue
to use the Linux in-kernel zerocopy splice() copy operation rather than
reading blocks into a userspace buffer. Note that this operation mode
does prevent the support of a number of
.B dd_rescue
features that can normally be used, such as falling back to smaller block
sizes, avoiding writes, sparse mode, repeat optimization, reverse direction
copy. A warning is issued to make the user aware.
.TP 8
.BR \-P ", " \-\-fallocate
results in 
.B dd_rescue
calling fallocate() on the output file, telling the filesystem how much
space to preallocate for the output file. (The size is determined by the
expected last position, as inferred from the input file length and 
.IR maxxfer
). On filesystems that support it, this results in them making better
allocation decisions, avoiding fragmentation. (Note that it does not
make sense to use sparse together with fallocate().)
.br
This option is only available if dd_rescue is compiled with fallocate()
support. For optimal support, it should be compiled with the 
libfallocate library.
.
.SS Misc options
.TP 8
.BR \-r ", " \-\-reverse
tells
.B dd_rescue
to copy in reverse direction, starting at 
.IR ipos
(with special case 0 meaning EOF) and working towards the beginning of
the file. This is especially helpful if the input file has a bad spot
which can be extremely slow to skip over, so approaching it from both
directions saves a lot of time (and may prevent further damage).
.br
Note that 
.B dd_rescue
does automatically switch to reverse direction copy, if input and output
file are identical and the input position is smaller than the output 
position, similar to the intelligence that memmove() uses to prevent
loss of data when overlapping areas are copied. The option -f / --force
does prevent this intelligence from happening.
.TP 8
.BR \-p ", " \-\-preserve
When copying files, this option does result in file metadata (timestamps,
ownership, access rights, xattrs) to be copied, similar to the option with the
same name in the cp program.
.br
Note that this option is only available if 
.B dd_rescue
has been compiled with libxattr support and the library can by dynamically
loaded on the system.
.TP 8
.BR \-t ", " \-\-truncate
tells
.B dd_rescue
to open the output file with O_TRUNC, resulting in the output file
(if it is a regular file) to be truncated to 0 bytes before writing
to it, removing all previous content that the file may have contained.
By default,
.B dd_rescue
does not remove previous content. 
.TP 8
.BR \-T ", " \-\-trunclast
tells 
.B dd_rescue
to truncate the output file to the highest copied position after the
copy operation completed, thus ensuring there's no data beyond the end
of the data that has been copied in this run.
.TP 8
.BR \-d ", " \-\-odir_in
instructs 
.B dd_rescue
to open
.IR infie
with O_DIRECT, bypassing the kernel buffers. While this option has a negative
effect on performance (the kernel does readahead for buffered I/O), it will
result in errors to be detected more quickly (kernel won't retry) and allows
for smaller I/O units (hardware sector size, 512bytes for most hard disks).
.br
O_DIRECT may not be available on all platforms.
.TP 8
.BR \-D ", " \-\-odir_out
tells
.B dd_rescue
to open
.IR outfile
with O_DIRECT, bypassing kernel buffers. This has a significant negative
effect on performance, as the program needs to wait for writes to hit the
disks as opposed to the asynchronous nature of buffered writeback.
On the flipside, the return status from writing is reliable this
way and smaller I/O chunks (hardware sector size, 512bytes) are possible.
.
.SS Logging
.TP 8
.BI \-l\  logfile \fR,\ \fB\-\-logfile= logfile
Unless in quiet mode, 
.B dd_rescue
does produce constant updates on the status of the copy operation to
stderr. With this option, these updates are also written to the specified
.IR logfile .
The control characters (to move the cursor up to overwrite the existing
status lines) are not written to the logfile.
.TP 8
.BI \-o\  bbfile \fR,\ \fB\-\-bbfile= bbfile
instructs 
.B dd_rescue
to write a list of bad blocks to 
.IR bbfile .
The file will contain a list of numbers (ASCII), one per line, where
the numbers indicate the offset in terms of 
.IR hardbs
sized blocks. The file format is compatible with that of badblocks.
Using dd_rescue on a block device (partition) and setting
.IR hardbs
to the block size of a filesystem that you want to create, you should
be able to feed the 
.IR bbfile
to mke2fs with the option -l.
.
.SS Multiple output files
.TP 8
.BI \-Y\  ofileX \fR,\ \fB\-\-outfile= ofileX \fR,\ \fB\-\-of= ofileX
If you want to copy data to multiple filess simultaneously, you can specify
this option. It can be specified multiple times, so many copies can be made.
Note that these files are secondary output files; they share file position
with the primary output file
.IR outfile .
Errors when writing to a secondary output file are ignored.
.
.SS Data protection by overwriting with random numbers
.TP 8
.BI \-z\  RANDSEED \fR,\ \fB\-\-random= RANDSEED
.PD 0
.TP
.BI \-Z\  RANDSEED \fR,\ \fB\-\-frandom= RANDSEED
.TP
.BI \-2\  RANDSEED \fR,\ \fB\-\-shred2= RANDSEED
.TP
.BI \-3\  RANDSEED \fR,\ \fB\-\-shred3= RANDSEED
.TP 
.BI \-4\  RANDSEED \fR,\ \fB\-\-shred4= RANDSEED
.PD 1
.\".PD 0
.\".IP "\fB\-5\fR \fIRANDSEED\fR,\ \fB\-\-shred5=\fR\fIRANDSEED\fR" 4
When you want to overwrite a file, partition or disk with random data,
using /dev/urandom (on Linux) as input is not a very good idea; the interface
has not been designed to yield a high bandwidth. It's better to use a
userspace Pseudo Random Number Generator (PRNG). With option -z / --random,
the C library's PRNG is used. With -Z / --frandom and the -2/-3/-4 / 
--shred2/3/4 options, an RC4 based PRNG is used.
.br
Note that in this mode, there is no
.IR infile
so the first non-option argument is the output file.
.br
The PRNG needs seeding; the C libraries PRNG takes a 32bit integer (4 bytes);
the RC4 based PRNG takes 256 bytes. If 
.IR RANDSEED 
is an integer, the integer
number will be used to seed the C library's PRNG. For the RC4 method, the C
library's PRNG then generates the 256 bytes to seed it. This creates
repeatable PRNG data. The RANDSEED value of 0 is special; it will create
a seedval that's based on the current time and the process' PID and should
be different for multiple runs of
.B dd_rescue .
.br
If 
.IR RANDSEED
is not an integer, it's assumed to be a filename from which the seed values
can be read. 
.B dd_rescue
will read 4 or 256 bytes from the file to seed the C library's or the RC4
PRNG. For good pseudo random numbers, using /dev/urandom to seed is a good idea.
.br
The modes -2/-3/-4 resp. --shred2/--shred3/--shred4 will overwrite the output
file multiple times; after each pass, fsync() will ensure that the data does
indeed hit the file. The last pass for these modes will overwrite the file
with zeroes. The rationale behind doing this is to make it easier to hide
that important data may have been overwritten, to make it easier for intelligent
storage systems (such as SSDs) to recycle the empty blocks and to allow for
better compression of a filesystem image containing such data.
.br
With -2 / --shred2, one pass with RC4 generated PRNG is happening and then
zeroes are written. With -3 / --shred3, there are two passes with RC4 PRNG
generated random numbers and a zero pass; the second PRNG pass writes the
inverse (bitwise reversed) numbers from the first pass. -4 / --shred4 works
like -3 / --shred3, with an additional pass with independent random numbers
as third pass.
.
.SS Plugins
Since version 1.42,
.B dd_rescue
has an interface for plugins. Plugins have the ability to analyze the
copied data or to transform it prior to it being written.
.
.TP 8
.BI \-L\  plugin1[=param1[:param2[:..]]][,plugin2[=..][,..]]
.PD 0
.TP
.BI \-\-plugins= plugin1[=param1[:param2[:..]]][,plugin2[=..][,..]]
.PD 1
loads plugins plugin1 ... and passes parameters to it. All plugins should support
at least the help parameter and provide information on their usage.
.br
Plugins may impose limits on dd_rescue. Plugins that look at the data
can't work with splice, as this avoids copying data to userspace. Also the
interface currently does not facilitate reverse direction copy.
Some plugins may impose further restrictions w.r.t. alignment of data in
the file or not using sparse detection.
.br
See section 
.B PLUGINS
for an overview of available plugins.
.

.SH PLUGINS
.SS null
The null plugin (ddr_null) does nothing, except if you specify the
.B lnchange
option in which case the plugin indicates to others that it transforms the
length of the output. This may be helpful for testing or to influence which
file the hash plugin considers for reading/writing extended attributes from/to
and for plugins to change their behavior with respect to hole detection.
.br
ddr_null_ddr also allows you to specify
.B debug
in which case it just reports the blocks that it passes on.
.
.SS hash
When the hash plugin (subsequently referred to as ddr_hash) is loaded, it 
will calculate a cryptographic hash over the 
copied data and print the result at the end of the copy operations.
The hash algorithm can be chosen by specifying
.B alg[o[rithm]]=ALG
where ALG is one of md5, sha1, sha256, sha224, sha512, sha384. (Specify
alg=help to get a list.)
To abbreviate the syntax, the alg= piece can be omitted.
.br
For backwards compatibility, the hash plugin can also be referred to with the
old MD5 name; it then defaults to the md5 algorithm.
.br
The computed value should be identical to calling md5sum/sha256sum/... on 
the target file (unless you only write part of the file),
but saves time by not accessing the (possibly large) file a second time.
The hash plugin handles sparse writes and arbitrary offsets fine.
.PP
ddr_hash accepts the parameter 
.B output
, which will cause ddr_hash to output
the cryptographic hash to stdout in the same format that md5sum/sha256sum/... use.
You can also specify
.B outfd=INT
to have the plugin write the hash to a different
file descriptor specified by the integer number INT. Note that ddr_hash
always processes data in binary mode and correctly indicates this with
a star (*) in the output generated with output/outfd=.
.br
ddr_hash also supports the parameter
.B append=STRING
which appends the given STRING to the output before computing the cryptographic
hash. Treating the STRING as a shared secret, this can actually be used to protect
against someone altering the contents (and recomputing the hash). It's thus a cheap
way of a cryptographic signature (but with preshared secrets as opposed to public
key cryptography).
.PP
You can store the cryptographic hash into the files by using the
.B set_xattr
option. The hash will be stored into the extended attribute user.checksum.ALG
by default, but you can override the name of the attribute by specifying
.B set_xattr=XATTR\.NAME
instead.
.br
ddr_hash will use the output file to write the xattr to, unless a plugin 
in the chain after ddr_hash indicates that it changes the file. (Currently,
a length change indicator is used, though that will change some day.) 
In that case, it will warn and use the input file, unless there's
another plugin before ddr_hash in the chain which transforms the contents/length
as well. In that case, there is no file that the checksum could be written
to and ddr_hash will report an error.
.B chk_xattr
will validate that the computed hash matches the one read from the extended
attribute. The same default attribute name applies and you can likewise override
it with
.B chk_xattr=XATTR\.NAME .
The check is only performed at the end of the copy, so copying will not
be prevented by wrong hashes; however the exit code of dd_rescue will
reflect a wrong hash. So copy to /dev/null and check the exit code if you
want to prevent writing data where the hash sum is broken. (If you want to
avoid running dd_rescue twice, you can copy to a temporary file, check
the exit value and then only move to the final name if checksums are
intact and otherwise discard.)
.br
ddr_hash will use the input file to read the xattr from, unless a plugin 
in the chain before ddr_hash indicates that it changes the file. (Currently,
a length change indicator is used, though that will change some day.) 
In that case, it will warn and use the output file, unless there's
another plugin after ddr_hash in the chain which transforms the contents/length
as well. In that case, there is no file that could hold a valid checksum
and ddr_hash will report an error.
.PP
Please note that the md5 algorithm is NOT recommended any more for
good protetction against malicious attempts to hide data modification;
it's not considered strong enough any more to prevent hash collisions.
sha1 is better, but the recommendation is to use the SHA-2 family of hashes.
On 32bit machines, I'd recommend sha256, while on 64bit machines, sha512
is faster and thus the best choice.
.
.SS lzo
The lzo plugin allows to compress and decompress data using liblzo2.
lzo is an algorithm that is faster than most other algorithms but
does not compress as well.
See the
.BR ddr_lzo (1)
man page for more details.
.
.SH EXIT STATUS
On successful completion, 
.B dd_rescue
returns an exit code of 0.
Any other exit code indicates that the program has aborted because of an 
error condition or that copying of the data has not been entirely successful.
.PP
.\"TODO: Better documentation of the error codes!
.
.SH EXAMPLES
.TP
.BI dd_rescue\ \-k\ \-P\ \-p\ \-t\ infile\ outfile
copies
.IR infile
to
.IR outfile
and does truncate the output file on opening (so deleting any previous data
in it), copies mode, times, ownerships at the end, uses fallocate to
reserve the space for the output file and uses efficient in kernel splice
copy method.
.TP
.BI dd_rescue\ \-A\ \-d\ \-D\ \-b\ 512\ /dev/sda\ /dev/sda
reads the contents of every sector of disk sda and writes it back to the
same location. Typical hard disks reallocate flaky and faulty sectors on 
writes, so this operation may result in the complete disk being usable
again when there were errors before. Unreadable blocks however will contain
zeroes after this.
.TP
.BI dd_rescue\ \-2\ /dev/urandom\ \-M\ outfile
overwrites the file
.IR outfile
twice; once with good pseudo random numbers and then with zeroes.
.TP
.BI dd_rescue\ \-t\ \-a\ image1.raw\ image2.raw
copies a filesystem image and looks for empty blocks to create a
sparse output file to save disk space. (If the source filesystem
has been used a bit, on that filesystem creating a large file with
zeroes and removing it again prior to this operation will result
in more sectors with zeroes. 
.BI dd_rescue\ \-u\ /dev/zero\ DUMMY
will achieve this ...)
.TP
.BI dd_rescue\ \-ATL\ hash=md5:output,lzo=compress:bench,MD5:output\ in\ out.lzo
copies the file
.IR in
to
.IR out.lzo
with using lzo (lzo1x_1) compression and calculating an md5 hash
(checksum) on both files. The md5 hashes for both are also written 
to stdout in the md5sum output format.
Note that the compress parameter to lzo is not strictly required 
here; the plugin could have deduced
it from the filenames. This example shows that you can specify multiple
plugins with multiple parameters; the plugins are forming a filter
chain. You can specify the same plugin multiple times.
.TP
.BI dd_rescue\ \-L\ hash=sha512:set_xattr,null=lnchange\ infile\ /dev/null
reads the file 
.IR infile
and computes its MD5 hash. It stores it in the input file's user.checksum.sha512
attribute. Note the use of the null plugin with faking a transformation due
to the lnchange parameter; this causes the hash plugin to write to the input
file which it would not normally have done. Of course this
will fail if you don't have the appropriate privileges to write xattrs to
infile.
.PP
See also README.dd_rescue and ddr_lzo(1) to learn about the possibilities.
.
.SH BUGS/LIMITATIONS
The source code does use the 64bit functions provided by glibc for file
positioning. However, your kernel might not support it, so you might be
unable to copy partitions larger then 2GB into a file.
.br
This program has been written using Linux and only tested on a couple of
Linux systems. People have reported to have successfully used it on
other Un*xish systems (such as xBSD or M*cOS), but these systems get little
regular test coverage; so please be advised to test properly (possibly
using the make check testsuite included with the source distribution) 
before relying on dd_rescue on non Linux based systems.
.br
Currently, the escape sequence for moving the cursor up is hard coded in the
sources. It's fine for most terminal emulations (including vt100 and linux),
but it should use the terminal description database instead.
.br
Since dd_rescue-1.10, non-seekable input or output files are supported,
but there's of course limitations to recover errors in such cases.
.PP
dd_rescue does not automate the recovery of faulty files or partitions
by automatically keeping a list of copied sectors and approaching bad spots
from both sides. There is a helper script dd_rhelp from LAB Valentin that
does this. Integration of such a mode into 
.B dd_rescue
itself is non-trivial and due to the complexity of the source code might
not happen.
.br
There also is a tool, GNU ddrescue, that is a reimplementation of this
tool and which contains the capabilities to automate recovery of bad
files in the way dd_rhelp does. It does not have the feature richness
of dd_rescue, but is reported to be easier to operate for error recovery
than dd_rescue with dd_rhelp.
.PP
Please report bugs to me via email.
.
.SS Data destruction considerations
The modes for overwriting data with pseudo random numbers to securely
delete sensitive data on purpose only implement a limited number of
overwrites. While Peter Gutmann's classic analysis concludes that the
then current harddisk technology requires more overwrites to be really
secure, the author believes that modern hard disk technology does not
allow data restoration of sectors that have been overwritten with the
--shred4 mode. This is in compliance with the recommendations from
BSI GSDS M7.15.
.br
Overwriting whole partitions or disks with random numbers is a fairly safe
way to destroy data, unless the underlying storage device does too much
magic. SSDs are doing fancy stuff in their Flash Translation Layer (FTL),
so this tool might be insufficient to get rid of data. Use 
SECURITY_ERASE (use hdparm) there or -- if available -- encrypt data with 
AES256 and safely destroy the key.
Normal harddisks have a small risk of leaking a few sectors
due to reallocation of flaky sectors.
.br
For securely destroying single files, your mileage may vary. The more advanced
your filesystem, the less likely dd_rescue's destruction will be effective.
In particular, journalling filesystems may carry old data in the journal.
Filesystems that do copy-on-write (COW) such as btrfs, are very likely to have
old copies of your supposedly erased file. It might help somewhat to fill the
filesystems with zeros (dd_rescue -u /dev/zero /path/to/fs/DUMMYNAME) to force
the filesystem to release and overwrite non-current data after overwriting
critical files with random numbers. If you can, better destroy a whole
partition or disk.
.
.SH SEE ALSO
.BR README.dd_rescue 
.BR README.dd_rhelp 
.BR ddr_lzo (1)
.br
.BR wipe (1)
.BR shred (1)
.BR ddrescue (1)
.BR dd (1)
.
.SH AUTHOR
Kurt Garloff <kurt@garloff.de>
.
.SH CREDITS
Many little issues were reported by Valentin LAB, the author of 
.B dd_rhelp .
.br
The RC4 PRNG (frandom) is a port from Eli Billauer's kernel mode PRNG.
.br
A number of recent ideas and suggestions came from Thomas.
.SH COPYRIGHT
This program is protected by the GNU General Public License (GPL) 
v2 or v3 - at your option.
.SH HISTORY
Since version 1.10, non seekable input and output files are supported.
.br
Splice copy -k is supported since 1.15.
.br
A progress bar exists since 1.17.
.br
Support for preallocation (fallocate) -P exists since 1.19.
.br
Since 1.23, we default to -y0, enhancing performance.
.br
The Pseudo Random Number modes have been started with 1.29.
.br
Write avoidance -W has been implemented in 1.30
.br
Multiple output files -Y have been added in 1.32.
.br
Long options and man page came with 1.33.
.br
Optimized sparse detection (SSE2, armv6, armv8 asm, AVX2) has 
been present since 1.35 and been enhanced until 1.43.
.br
We support copying extended attributes since 1.40 using
libxattr.
.br
Removing and (fs)trimming the output file's filesystem
exists since 1.41. Support for compilation with bionic
(Android's C library) with most features enabled also 
came with 1.41.
.br
Plugins exist since 1.42, the MD5 plugin came with 1.42, the
lzo plugin with 1.43. 1.44 renamed the MD5 plugin to hash and
added support for the SHA-2 family of hashes.
.PP
Some additional information can be found on
.br
http://garloff.de/kurt/linux/ddrescue/
.br
LAB Valentin's 
.B dd_rhelp
can be found on
.br
http://www.kalysto.org/utilities/dd_rhelp/index.en.html
